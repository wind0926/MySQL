# MySQL
关于MySQL相关内容复习
MySQL

1. 优化查询的方法？ 
1.使用索引
     应尽量避免全表扫描，首先应考虑在 where 及 order by ,group by 涉及的列上建立索引。
2.优化 SQL 语句
     2.1 通过 explain(查询优化神器)用来查看 SQL 语句的执行效果， 可以帮助选择更好的索引和优化查询语句， 写出更好的优化语句。 通 常我们可以对比较复杂的尤其是涉及到多表的 SELECT 语句， 把关 键字 EXPLAIN 加到前面， 查看执行计划。例如： explain select * from news; 
     2.2 任何地方都不要使用 select * from t ， 用具体的字段列表代 替“*” ， 不要返回用不到的任何字段。 
     2.3 不在索引列做运算或者使用函数。 
     2.4 查询尽可能使用 limit 减少返回的行数， 减少数据传输时间和 带宽浪费。
3.优化数据库对象
3.2 对表进行拆分 
     通过拆分表可以提高表的访问效率。 有 2 种拆分方法： 
     1.垂直拆分： 
     把主键和一些列放在一个表中， 然后把主键和另外的列放在另 一个表中。 如果一个表中某些列常用， 而另外一些不常用， 则可以 采用垂直拆分。 
     2.水平拆分： 
     根据一列或者多列数据的值把数据行放到二个独立的表中。 
3.3 使用中间表来提高查询速度 

4.硬件优化 
4.1 CPU 的优化 
     选择多核和主频高的 CPU。 
2. 如果有一个特别大的访问量到数据库上，怎么做优化？
1.使用优化查询的方法（见上面）
2.主从复制， 读写分离， 负载均衡
     目前，大部分的主流关系型数据库都提供了主从复制的功能，通过配置两台（或多台） 数据库的主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站可 以利用数据库的这一功能，实现数据库的读写分离，从而改善数据库的负载压力。一个系 统的读操作远远多于写操作，因此写操作发向 master，读操作发向 slaves 进行操作（简 单的轮循算法来决定使用哪个 slave）。 

    
主从复制的原理： 
     影响 MySQL-A 数据库的操作，在数据库执行后，都会写入本地的日志系统 A 中。 假设，实时的将变化了的日志系统中的数据库事件操作，通过网络发给 MYSQL-B。 MYSQL-B 收到后，写入本地日志系统 B，然后一条条的将数据库事件在数据库中完成。 那么，MYSQL-A 的变化，MYSQL-B 也会变化，这样就是所谓的 MYSQL 的复制。 
     在上面的模型中，MYSQL-A 就是主服务器，即 master，MYSQL-B 就是从服务器，即 slave。 

主从复制的几种方式： 
1.同步复制 
     主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，必须等待验证所 有的从服务器的更新数据是否已经复制到其中，之后才可以自由处理其它进入的事务处理 请求。
2.异步复制 
     主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，无需等待验证更 新数据是否已经复制到从服务器中，就可以自由处理其它进入的事务处理请求。
3.半同步复制 
     主服务器在将更新的数据写入它的二进制日志（Binlog）文件中后，只需等待验证其 中一台从服务器的更新数据是否已经复制到其中，就可以自由处理其它进入的事务处理请 求，其他的从服务器不用管。 
3. 数据库分表， 分区， 分库
     分表见上面描述。 
     分区就是把一张表的数据分成多个区块，这些区块可以在一个磁盘上，也可以在不同 的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同 时处理不同的请求，从而提高磁盘 I/O 读写性能，实现比较简单。 包括水平分区和垂直分 区。 
     分库是根据业务不同把相关的表切分到不同的数据库中，比如 web、bbs、blog 等库。 

3. 内连接与外连接的区别？
内连接（inner join） ： 只显示符合连接条件的记录。SQL>select * from t1 inner join t2 on t1.id=t2.id;
 外连接分左外连接、 右外连接、 全外连接三种。
1） 左外连接（LEFT JOIN 或 LEFT OUTER JOIN ） 
     即以左表为基准，到右表找匹配的数据，找不到匹配的用 NULL 补齐。 
     显示左表的全部记录及右表符合连接条件的记录。 
2） 右外连接（RIGHT JOIN 或 RIGHT OUTER JOIN ）
3）全外连接（FULL JOIN 或 FULL OUTER JOIN） 
     除了显示符合连接条件的记录外，在 2 个表中的其他记录也显示出来。 即以右表为基准，到左表找匹配的数据，找不到匹配的用 NULL 补齐。 
     显示右表的全部记录及左表符合连接条件的记录。 

4. 存储过程的概念以及优缺点是什么？
     存储过程:就是一些编译好了的 sql 语句,这些 SQL 语句代码 像一个方法一样实现一些功能(对单表或多表的增删改查),然后 再给这个代码块取一个名字,在用到这个功能的时候调用他就行了。
优点:
1.存储过程因为 SQL 语句已经预编译过了,因此运行的速度比 较快。
2.存储过程在服务器端运行,减少客户端的压力。
缺点:
     调试麻烦(至少没有像开发程序那样容易),可移植性不灵活(因 为存储过程是依赖于具体的数据库)。
5. 数据库的三级范式？
     1NF:字段不可再分,原子性。
     2NF:满足第二范式( 2NF )必须先满足第一范式( 1NF )。 一个表只能说明一个事物。非主键属性必须完全依赖于主键属性。
     3NF:满足第三范式( 3NF ) 必须先满足第二范式( 2NF ) 。每 列都与主键有直接关系,不存在传递依赖。 任何非主属性不依赖于其它 非主属性。
6. 数据库事务正确执行的四个基本要素（事务的四个属性）。
     ACID:原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、 持久性(Durability)。 
     原子性:一个事务(transaction)中的所有操作,要么全部完成,要么全部不完成。 
     一致性:在事务操作前后数据总量保持不变。
 隔离性:事务之前相互独立。
     持久性:一个事务一旦提交,它对数据库中数据的改变就应该是永久性的,并不会被 回滚。 
7. 并发事务带来的问题。
1.脏读；一个事务读取到另外事务的数据。
2.不可重复读；是指在一个事务内,多次读同一数据。在这个事务还没有结束时,另外一 个事务也访问该同一数据。那么,在第一个事务中的两次读数据之间,由于第 二个事务的修改,那么第一个事务两次读到的的数据可能是不一样的。这样就 发生了在一个事务内两次相同的查询读到的数据是不一样的,因此称为是不可 重复读。 
3.幻读。 目前工资为 5000 的员工有 10 人,事务 A 读取所有工资为 5000 的人数为 10 人。此时,事务 B 插入一条工资也为 5000 的记录。这是,事务 A 再次读取 工资为 5000 的员工,记录为 11 人。此时产生了幻读。
8. 并发控制的方式（如何解决并发问题）。
     加锁,如乐观锁和悲观锁。
9. 数据库事物的隔离级别介绍、举例说明。
  
数据库提供了 4 种隔离级别(由低到高):
这 4 个级别可逐个解决脏读,不可重复读和幻读这几个问题。
1.读未提交数据 
read uncommitted;
2.读已提交数据 
  read committed;
3.可重复读(Mysql 的默认隔离级别) 
  repeatable read;
4.可串行化 
    serializable;
10. MySQL事务控制语句。
     *BEGIN 或 START TRANSACTION:*显示地开启一个事务;      COMMIT:提交事务,并使已对数据库进行的所有修改称为永久性的;      ROLLBACK:回滚会结束用户的事务,并撤销正在进行的所有未提交的修改;
11. 数据库怎么保证数据的一致性。
事务，悲观锁，乐观锁。
12. 如何并发访问数据库
     锁是一种并发控制技术,锁是用来在多个用户同时访问同一个数据的时候 保护数据的 
产生死锁的四个必要条件: 
(1) 互斥条件:一个资源每次只能被一个进程使用。 
(2) 请求与保持条件:一个进程因请求资源而阻塞时,对已获得的资源保持不放。 
(3) 不可剥夺条件:进程已获得的资源,在末使用完之前,不能强行剥夺。 
(4) 环路等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
     只要系统发生了死锁,这些条件必然成立,而只要上述条件之一不满足,就不会发生死 锁。 
预防死锁 
     预防死锁的发生只需破坏死锁产生的四个必要条件之一即可。 
避免死锁 
     银行家算法。

13. mysql 锁的粒度(即锁的级别)
1.表级锁,直接锁定整张表,在你锁定期间,其它进程无法对该表进行写操作。
2.行级锁,仅对指定的记录进行加锁,这样其它进程还是可以对同一个表中的其它记 录进行操作。
3.页级锁,一次锁定相邻的一组记录。
14乐观锁的实现方式:
1.大多是基于数据版本(Version)记录机制实现,需要为每一行数据增加 一个版本标识(也就是每一行数据多一个字段 version),每次更新数据都要 更新对应的版本号+1。 
     工作原理:读出数据时,将此版本号一同读出,之后更新时,对此版本号 加一。此时,将提交数据的版本信息与数据库表对应记录的当前版本信息进行 比对,如果提交的数据版本号大于数据库表当前版本号,则予以更新,否则认 为是过期数据,不得不重新读取该对象并作出更改。
15. truncate 与 delete 的区别是什么?
DELETE TABLE:删除内容、不删除定义,不释放空间。 
TRUNCATE TABLE:删除内容、不删除定义、释放空间。
DROP TABLE:删除内容和定义,释放空间。 

16. sql 的授权语句和收回权限语句?
grant 权限 on 数据库对象 to 用户
grant insert on scott.Employees to user1,user2;
revoke 权限 on 数据库对象 from 用户
17. 怎么新加一行记录、怎么添加一个列字段,修改列 ?
插入一行数据:
insert into stu(stuName,stuAge,stuSex) values('张三','20','男')
增加列:
alter table tableName add (column)columnName varchar(30) (一定要有数据类型!!!)
删除列:
 alter table tableName drop (column) columnName
17. select Count (*) 和 Select Count( 数 字 ) 以 及 Select Count(column)区别。
     count(*) 跟 count(1) 的结果一样,返回记录的总行数,都包括 对 NULL 的统计,而 count(column) 是不包括 NULL 的统计。 
 
18. EXISTS 关键字的使用方法?
     EXISTS 关键字表示存在。使用 EXISTS 关键字时,内层查询语句不返回查询的记录, 而是返回一个真假值。 
     如果内层查询语句查询到符合条件的记录,就返回一个真值(true),否则,将返回 一个假值(false):
当返回的值为 true 时,外层查询语句将进行查询。
当返回的值为 false 时,外层查询语句将不进行查询或者查询不出任何记录。
实例 1
     如果 department 表中存在 d_id 取值为 1003 的记录, 则查询 employee 表的记录。SELECT 语句的代码如下:
SELECT * FROM employee
    WHERE EXISTS
    (SELECT d_name FROM department WHERE d_id=1003);
     因为 department 表中存在 d_id 值为 1003 的记录,内层查询语句返回一个 true,外层 查询语句接收 true 后,开始查询 employee 表中的记录。因为没有设置查询 employee 表的 查询条件,所以查询出了 employee 表的所有记录。
19. 有一个学生表,有三个字段:name 、course 、score ,每一个学生都有三门课程,比如数学、语文、英语,写 sql 语句,查找出三门课程的成绩都大于 80 的学生。
SELECT S.name
  FROM Student S
  GROUP BY S.name
  Having MIN(S.score)>=80
20. 判断表的字段值是否为空
1、查询字段值为空的语法:where <字段名> is null 
2、查询字段值不为空的语法:where <字段名> is not null 或者 where NoT(<字段名> IS NULL) 
21.性别字段为什么不适合加索引?从 B+树原理解释。
     尽量选择区分度高的字段作为索引,区分度的公式是 count(distinct col)/count(*),表示 字段不重复的比例,比例越大我们扫描的记录数越少,唯一键的区分度是 1,而一些状态、 性别字段可能在大数据面前区分度就是 0。在性别字段上增加索引,并不能明显加快检索 速度。
22.索引是什么？索引能跟干什么？
索引是帮助mysql高效获取数据的数据结构。索引非常关键，尤其当表中的数据量越来越大时，索引对于性能的影响愈发重要，可以将查询性能提升好几个数量级，总的来说可以明显的提高查询效率。

23.索引的分类
1.从存储结构上划分：BTree索引、Hash索引、全文索引。
2.从引用层次：普通索引、唯一索引、复合索引。

24. 数据库索引的原理(实现)。
     目前大部分数据库系统及文件系统都采用 B-Tree( B 树)或其变种 B+Tree (B+树)作为索引结构。B+Tree 是数据库系统实现索引的首选数据结构。      
在 MySQL 中,索引属于存储引擎级别的概念,不同存储引擎对索引的实现方式 是不同的,本文主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。 MyISAM 索引实现 
     MyISAM 引擎使用 B+Tree 作为索引结构,叶节点的 data 域存放的是数据记录 的地址。下图是 MyISAM 索引的原理图: 

虽然 InnoDB 也使用 B+Tree 作为索引结构,但具体实现方式却与 MyISAM 截 然不同。 
     1.第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道, MyISAM 索引文件和数据文件是分离的,索引文件仅保存数据记录的地址。而在 InnoDB 中,表数据文件本身就是按 B+Tree 组织的一个索引结构,这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键,因此 InnoDB 表数 据文件本身就是主索引。 

25. Mysql 的 B+树索引的优点?为什么不用二叉树?B-树和 B+树为什么比红黑树更合适?
     数据库文件很大,需要存储到磁盘上,索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。 
1.高度原因 
     B+树中的每个结点可以包含大量的关键字,这样树的深度降低了,所以任何关键 字的查找必须走一条从根结点到叶子结点的路,所有关键字查询的路径长度相同,导致 每一个数据的查询效率相当, 这就意味着查找一个元素只要很少结点从外存磁盘中读入 内存,很快访问到要查找的数据,减少了磁盘 I/O 的存取次数。 
2.磁盘预读原理和局部性原理 
     将一个节点的大小设为等于一个页,这样每个节点只需要一次 I/O 就可以完全载 入。
26.建索引的几大原则。
1.更新频繁的列不应设置索引；
2.数据量小的表不要设置索引；
3.重复数据多的字段不要设置索引（比如：性别）。
4.首先考虑对where和order by 涉及到的列建立索引。


27. mysql 中 MyIsam 与 InnoDB 的区别,至少 5 点。
     Mysql 数据库中,最常用的两种引擎是 innordb 和 myisam。InnoDB 是 Mysql 的默 认存储引擎。 
1.事务处理上方面 
     MyISAM 强调的是性能,查询的速度比 InnoDB 类型更快,但是不提供事务支持。 
     InnoDB 提供事务支持事务。 
2.外键 
     MyISAM 不支持外键,InnoDB 支持外键。 
2.锁 
     MyISAM 只支持表级锁,InnoDB 支持行级锁和表级锁,默认是行级锁,行锁大幅 度提高了多用户并发操作的性能。innodb 比较适合于插入和更新操作比较多的情况, 而 myisam 则适合用于频繁查询的情况。另外,InnoDB 表的行锁也不是绝对的,如果 在执行一个 SQL 语句时,MySQL 不能确定要扫描的范围,InnoDB 表同样会锁全表, 例如 update table set num=1 where name like “%aaa%”。 
3.全文索引 
     MyISAM 支持全文索引, InnoDB 不支持全文索引。innodb 从 mysql5.6 版本开始提 供对全文索引的支持。 
4.表主键 
     MyISAM:允许没有主键的表存在。 
     InnoDB:如果没有设定主键,就会自动生成一个 6 字节的主键(用户不可见)。 
5.表的具体行数 
     MyISAM:select count() from table,MyISAM 只要简单的读出保存好的行数。因为 MyISAM 内置了一个计数器,count()时它直接从计数器中读。 
     InnoDB: 
不保存表的具体行数,也就是说,执行 select count(*) from table 时, InnoDB 要扫描一遍整个表来计算有多少行。
28. 一张表,里面有 ID 自增主键,当 insert 了 17 条记录之后,删除了第 15,16,17 条记录,再把 Mysql 重启,再 insert 一条记录,这条记录的 ID 是 18 还是 15 ?
     如果表的类型是 MyISAM,那么是 18。 
因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里,重启 MySQL 自增主键的最大 ID 也不会丢失。 
     如果表的类型是 InnoDB,那么是 15。 
InnoDB 表只是把自增主键的最大 ID 记录到内存中,所以重启数据 库会导致最大 ID 丢失。 
29. 数据库连接池的原理?连接池使用什么数据结构实现?实现连接池?
原理:一般来说,java 应用程序访问数据库的过程是: 
	1.导入jar包；
	2注册驱动：Class.ForName();
3.获取数据库连接对象：DriverManager.getConnection；
4.定义sql语句
5..获取执行sql语句的对象PrepStatement state =con.createStatement();
6.为？赋值 
7.查询数据库并返回结果 ResultSet result =state.executeQuery 
8.断开连接



